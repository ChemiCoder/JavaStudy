# 对象与类

##一. 面向对象
类：构造对象的模板或蓝图。封装继承
###类之间的关系
依赖(use-a) 聚合(has-a) 类A的对象包含类B的对象继承(is-a)
###对象
对象变量不是一个对象，也没有引用对象，不能将方法应用于这个变量上，需要将这个变量初始化。GregorianCalendar类所包含的方法比Date类多。通常习惯在访问器方法名前加上前缀get，更改器方法前面加上set对实例域做出修改的方法称为**更改器方法**
仅访问实例域而不进行修改的方法称为**访问器方法**编译源文件的方法：由于某个类使用了另一个类，及时没有显示编译，但是仍会由于引用相关的类而被编译。
## 二. 继承
###类
 超类 superclass 基类 base class 父类 parent class  子类 subclass 派生类 derived class child class
###声明
```
class ClassName{field1field2constuctor1method1}
```
###继承层次
有一个公共超类派生出来的所有类的集合被称为继承层次，在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承类。
###多态
is-a规则：置换法则，程序中出现超类对象的任何地方都可以用子类对象置换。不能将超类的引用赋给子类变量
###动态绑定
编译器查看对象的声明类型和方法名编译器将查看调用方法时提供的参数类型，重载解析。 方法的名字和参数列表称为方法的签名。private static final 方法或者构造器 静态绑定，调用的方法依赖于隐式函数当程序运行时并且采用动态绑定调用方法式，虚拟机一定调用与所引用对象的实际类型最合适的那个类每次调用方法搜索开销较大，虚拟机预先为每个类创建了一个方法表method table覆盖一个方法的时候，子类方法不能低于超类方法的可见性。
###阻止继承
不允许扩展的类被称为final类```final class Executive extends Manager{ ···}```类中的特定方法也可以被声明为final，子类就不能覆盖这个方法。一个类声明为final，但是域不是final ??? 内联方法
###强制类型转换
```double x=10.987;int nx=(int)X;```在进行类型转换之前应该检查一下能否成功转换。???? 一个子类的引用赋给一个超类变量，但是一个超类的引用赋给一个子类变量，必须进行类型转换，才能够通过运行时的检查。只能在继承层次内进行类型转换在将超类转换为子类之前，应该使用instanceof进行检查。

###抽象类
抽象类 abstract ，不能够实例化
###受保护访问
protected 超类中的某些方法允许被子类访问，允许子类的方法访问超类的某个域。

##Object对象
是java所有类的始祖，如果没有明确的指出，Object就是这个类的超类。
###equals方法
用于检测一个对象是否等于另外一个对象，判断两个对象是否具有相同的引用。

##泛型数组列表
ArrayList 具有自动调节数组容量的功能，采用类型参数的泛型类，指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面ArrayList<Employee>声明和构造一个保存employee对象的数组列表
```ArrayList<Employee> staff=new ArrayList<Employee> ();在java7，省去右边的类型参数ArrayList<Employee> staff=new ArrayList<>();```###add方法
将元素添加到数组列表中。


